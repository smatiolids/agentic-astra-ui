import { createReactAgent } from '@langchain/langgraph/prebuilt';
import { ChatOpenAI } from '@langchain/openai';
import { z } from 'zod';
import {
  ToolSpecInputV2,
  ToolParameterSchema,
  ToolSpecSchema,
  ToolSpecResponseSchema,
  type ToolSpec,
  type ToolSpecResponse,
  getAllSchemaDescriptions,
} from '@/lib/toolSpecSchemas';
import { buildTools } from '@/lib/toolSpecTools';

function parseJsonResponse(responseContent: string) {
  try {
    return JSON.parse(responseContent);
  } catch (parseError) {
    const jsonMatch =
      responseContent.match(/```json\s*([\s\S]*?)\s*```/) ||
      responseContent.match(/```\s*([\s\S]*?)\s*```/);
    if (jsonMatch) {
      return JSON.parse(jsonMatch[1]);
    }
    throw new Error('Failed to parse agent response as JSON');
  }
}

function normalizeMessageContent(content: unknown) {
  if (typeof content === 'string') {
    return content;
  }
  if (Array.isArray(content)) {
    return content
      .map((part) => {
        if (typeof part === 'string') {
          return part;
        }
        if (part && typeof part === 'object' && 'text' in part) {
          return String((part as { text: string }).text);
        }
        return '';
      })
      .join('');
  }
  return '';
}

/**
 * Transforms parameters from object format to array format if needed
 * Converts: { "param_name": {...} } to [{ "param": "param_name", ... }]
 */
function transformParametersToArray(parameters: any): any[] {
  if (Array.isArray(parameters)) {
    return parameters;
  }
  
  if (parameters && typeof parameters === 'object') {
    return Object.entries(parameters).map(([paramName, paramData]: [string, any]) => {
      // If it's already in the correct format, return as is
      if (paramData && typeof paramData === 'object' && 'param' in paramData) {
        return paramData;
      }
      
      // Transform from object format to array format
      return {
        param: paramName,
        paramMode: paramData?.paramMode || 'tool_param',
        type: paramData?.type || 'string',
        description: paramData?.description || `Parameter for ${paramName}`,
        attribute: paramData?.attribute || paramName,
        operator: paramData?.operator,
        required: paramData?.required !== undefined ? paramData.required : false,
        value: paramData?.value,
        expr: paramData?.expr,
        info: paramData?.info || '',
      };
    });
  }
  
  return [];
}


function buildSystemPrompt(): string {
  const schemaDescriptions = getAllSchemaDescriptions();
  
  return `
You are an expert at creating database query tool specifications. Use the tools provided to inspect schema and sample data.

CRITICAL: Your final response MUST be a JSON object with this exact structure:
{
  "toolSpec": {
    // Complete tool specification object
  },
  "explanation": "optional - summary of the execution"
}

The "toolSpec" field must contain a complete tool specification with ALL required fields.

${schemaDescriptions}

IMPORTANT RULES FOR toolSpec:
- If dataType is "collection", include "collection_name" and omit "table_name"
- If dataType is "table", include "table_name" and omit "collection_name"
- CRITICAL: "parameters" MUST be an ARRAY of objects, NOT an object with keys. Each parameter object must follow the ToolParameter schema above
- Only include partition keys, sorting keys, and indexed columns as parameters
- Partition keys are mandatory parameters
- For indexed date/time or timestamp parameters, generate start_<column_name> and end_<column_name> parameters using $gt and $lte operators
- For indexed numeric parameters, generate min_<column_name> and max_<column_name> parameters using $gte and $lte operators
- If a column is a vector column, generate the embedding_model as text-embedding-3-small
- Include "info" field explaining why each parameter was considered (e.g., "it is an indexed column", "it is a partition key")
- The explanation field should provide a summary of the execution
- The paramMode should be always tool_param, which indicates that its value will be generated by the agent. Use static or expression only if the user asked for a condition that will not be controlled by the agent.
- - E.g: The user asked to add a filter for future dates, then use a python expression using the datetime library iand the operator $gte.
- - E.g: The user asked for records where a field has the value "John", then use a static value and the operator $eq.
`;
}

function buildAgentPrompt(input: ToolSpecInputV2) {
  const userPrompt = input.prompt?.trim() || 'No additional instructions provided.';
  const existingSpec =
    input.existingToolSpec && Object.keys(input.existingToolSpec).length > 0
      ? JSON.stringify(input.existingToolSpec, null, 2)
      : '';

  return `

User Request:
${userPrompt}

${existingSpec ? `Existing Tool Spec (update this based on the new request):\n${existingSpec}\n` : ''}

Target ${input.dataType}: ${input.name}
Database: ${input.dbName || 'default'}

`;
}

export async function generateToolSpecV2(input: ToolSpecInputV2) {

  const baseLlm = new ChatOpenAI({
    apiKey: process.env.OPENAI_API_KEY,
    model: input.model || process.env.OPENAI_MODEL || 'gpt-4o-mini',
    temperature: 0.3,
  });

  // Create structured output LLM for the final response
  // This ensures the tool spec matches the Zod schema exactly
  const structuredLlm = baseLlm.withStructuredOutput(ToolSpecSchema, {
    name: 'tool_specification',
    method: 'jsonMode', // Uses OpenAI's JSON mode for reliable structured output
  });

  // Create structured output LLM for responses that may include explanations
  const responseLlm = baseLlm.withStructuredOutput(ToolSpecResponseSchema, {
    name: 'tool_specification_response',
    method: 'jsonMode',
  });

  const tools = await buildTools();
  const agent = createReactAgent({
    llm: baseLlm, // Use base LLM for tool calls
    tools,
  });

  try {
    // First, let the agent gather information using tools
    const systemPrompt = buildSystemPrompt();
    const agentResult = await agent.invoke({
      messages: [
        {
          role: 'system',
          content: systemPrompt,
        },
        {
          role: 'user',
          content: buildAgentPrompt(input),
        },
      ],
    });

    // Extract the conversation history from the agent
    const agentMessages = Array.isArray(agentResult?.messages) ? agentResult.messages : [];
    
    // Check if there's an existing tool spec to return in case of invalid requests
    const existingSpec = input.existingToolSpec && Object.keys(input.existingToolSpec).length > 0
      ? input.existingToolSpec
      : null;
    
    // Make a final structured call to generate the tool spec or explanation
    // Include all the agent's messages as context
    const structuredMessages = [
      {
        role: 'system' as const,
        content: systemPrompt,
      },
      ...agentMessages.map((msg: any) => ({
        role: msg.role || 'assistant',
        content: normalizeMessageContent(msg.content),
      })),
      {
        role: 'user' as const,
        content: `Based on the information gathered and validation performed, generate the tool specification response.

CRITICAL STRUCTURE REQUIREMENT:
You MUST return a JSON object with this EXACT structure - do NOT return just a tool spec, it MUST be wrapped:
{
  "toolSpec": {
    // Complete tool specification object with ALL required fields
  },
  "explanation": "string" // OPTIONAL - summary of the execution
}

The "toolSpec" field is REQUIRED and must contain a complete tool specification object.
The "explanation" field is OPTIONAL and returns a summary of the execution.

${getAllSchemaDescriptions()}

Remember for the toolSpec object inside "toolSpec":
- If dataType is "collection", include "collection_name" and omit "table_name"
- If dataType is "table", include "table_name" and omit "collection_name"
- Must include all required fields as specified in the ToolSpec schema above
- CRITICAL: "parameters" MUST be an ARRAY, not an object. Each parameter must follow the ToolParameter schema above. Example format:
  "parameters": [
    {
      "param": "customer_id",
      "paramMode": "tool_param",
      "type": "string",
      "description": "Customer ID",
      "attribute": "customer_id",
      "operator": "$eq",
      "required": true,
      "info": "it is a partition key"
    }
  ]
- Follow all the IMPORTANT RULES from the system prompt`,
      },
    ];

    try {
      const response = await responseLlm.invoke(structuredMessages);
      
      // Validate the response structure
      if (!response || typeof response !== 'object') {
        throw new Error('Invalid response structure: response is not an object');
      }
      
      if (!('toolSpec' in response)) {
        throw new Error('Invalid response structure: missing "toolSpec" field');
      }
      
      // Transform parameters from object to array if needed
      if (response.toolSpec && typeof response.toolSpec === 'object' && 'parameters' in response.toolSpec) {
        response.toolSpec.parameters = transformParametersToArray(response.toolSpec.parameters);
      }
      
      // Validate toolSpec structure
      const validationResult = ToolSpecSchema.safeParse(response.toolSpec);
      if (!validationResult.success) {
        console.error('ToolSpec validation failed:', validationResult.error);
        throw new Error(`Invalid toolSpec structure: ${validationResult.error.message}`);
      }
      
      return response;
    } catch (structuredError: any) {
      // If structured output fails, try to parse manually as fallback
      console.error('Structured output failed, attempting fallback parsing:', structuredError);
      
      // Try to get the raw response from the agent messages
      const lastAgentMessage = agentMessages[agentMessages.length - 1];
      const rawContent = normalizeMessageContent(lastAgentMessage?.content || '');
      
      // Try to extract JSON from the content
      try {
        const parsed = parseJsonResponse(rawContent);
        
        // Helper function to transform parameters in a tool spec
        const transformToolSpec = (spec: any) => {
          if (spec && typeof spec === 'object' && 'parameters' in spec) {
            spec.parameters = transformParametersToArray(spec.parameters);
          }
          return spec;
        };
        
        // If it looks like a tool spec (not wrapped), wrap it
        if (parsed && typeof parsed === 'object' && !('toolSpec' in parsed)) {
          const transformedSpec = transformToolSpec(parsed);
          const wrapped = {
            toolSpec: transformedSpec,
            explanation: undefined,
          };
          
          // Validate the wrapped response
          const validationResult = ToolSpecResponseSchema.safeParse(wrapped);
          if (validationResult.success) {
            console.log('Successfully parsed and wrapped response');
            return wrapped;
          }
        } else if (parsed && typeof parsed === 'object' && 'toolSpec' in parsed) {
          // Already wrapped, transform parameters and validate
          parsed.toolSpec = transformToolSpec(parsed.toolSpec);
          const validationResult = ToolSpecResponseSchema.safeParse(parsed);
          if (validationResult.success) {
            console.log('Successfully parsed wrapped response');
            return parsed;
          }
        }
      } catch (parseError) {
        console.error('Fallback parsing also failed:', parseError);
      }
      
      // If all else fails, throw the original error
      throw new Error(`Failed to generate valid tool specification: ${structuredError.message || structuredError}`);
    }
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown agent error';
    throw error;
  }
}
