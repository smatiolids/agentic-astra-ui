import { z } from 'zod';

export type DataType = 'collection' | 'table';

export type ToolSpecInputV2 = {
  dataType: DataType;
  name: string;
  dbName?: string;
  prompt?: string;
  existingToolSpec?: any;
  model?: string;
};

// Zod schema for structured output matching the JSON structure in the prompt
export const ToolParameterSchema = z.object({
  param: z.string().describe('Parameter name'),
  paramMode: z.enum(['tool_param', 'static', 'expression']).describe('Default is tool_param. Static: A static filter value was asked; Expression: the filter is generated by a python expression'),
  type: z.enum(['string', 'number', 'boolean', 'text', 'timestamp', 'float', 'vector']).describe('Parameter type - UUIDs should be treated as string'),
  description: z.string().describe('Parameter description'),
  attribute: z.string().describe('Attribute name from list'),
  operator: z.enum(['$eq', '$gt', '$gte', '$lt', '$lte', '$in', '$ne']).optional().describe('Query operator'),
  required: z.boolean().describe('Whether parameter is required'),
  value: z.string().optional().describe('Static value if paramMode is static'),
  expr: z.string().optional().describe('Python expression if paramMode is expression'),
  info: z.string().describe('Why the parameter was considered (e.g., indexed column, partition key)'),
});

export const ToolSpecSchema = z.object({
  name: z.string().describe('Tool name slug'),
  title: z.string().describe('Descriptive tool name'),
  description: z.string().describe('Clear description of what this tool does'),
  type: z.literal('tool').describe('Tool type'),
  method: z.literal('find').describe('Query method'),
  collection_name: z.string().optional().describe('Collection name if dataType is collection, otherwise remove it'),
  table_name: z.string().optional().describe('Table name if dataType is table, otherwise remove it'),
  db_name: z.string().describe('Database name'),
  parameters: z.array(ToolParameterSchema).describe('Array of tool parameters. MUST be an array of objects'),
  projection: z.record(z.string(), z.number()).describe('Projection object mapping attribute names to 1'),
  limit: z.number().describe('Result limit'),
  enabled: z.boolean().describe('Whether tool is enabled'),
  tags: z.array(z.string()).optional().describe('Optional relevant tags separated by comma'),
});

export type ToolSpec = z.infer<typeof ToolSpecSchema>;

// Response schema that includes optional explanation for invalid requests
export const ToolSpecResponseSchema = z.object({
  toolSpec: ToolSpecSchema.describe('The complete tool specification object. Must include all required fields: name, title, description, type, method, parameters, projection, limit, enabled, tags, and either collection_name or table_name based on dataType.'),
  explanation: z.string().optional().describe('Explanation when request cannot be fulfilled (e.g., invalid column requested). Only include this field if the user requested something that cannot be done.'),
});

export type ToolSpecResponse = z.infer<typeof ToolSpecResponseSchema>;

/**
 * Extracts description from a Zod schema, handling optional and array types
 */
function extractDescription(zodField: z.ZodTypeAny): string | undefined {
  // Handle optional fields - unwrap to get the inner type
  if (zodField instanceof z.ZodOptional) {
    return extractDescription(zodField._def.innerType);
  }
  
  // Handle array fields - get description from element type
  if (zodField instanceof z.ZodArray) {
    return extractDescription(zodField._def.type);
  }
  
  // Get description from the field itself
  return zodField._def?.description;
}

/**
 * Extracts field descriptions from a Zod object schema
 */
function extractSchemaDescriptions(schema: z.ZodObject<any>): Record<string, string> {
  const descriptions: Record<string, string> = {};
  const shape = schema.shape;
  
  for (const [key, fieldSchema] of Object.entries(shape)) {
    const zodField = fieldSchema as z.ZodTypeAny;
    const description = extractDescription(zodField);
    if (description) {
      descriptions[key] = description;
    }
  }
  
  return descriptions;
}

/**
 * Gets the type name from a Zod schema
 */
function getZodTypeName(zodField: z.ZodTypeAny): string {
  const typeName = zodField._def?.typeName;
  
  if (zodField instanceof z.ZodArray) {
    const elementType = getZodTypeName(zodField._def.type);
    return `array<${elementType}>`;
  }
  
  if (zodField instanceof z.ZodOptional) {
    return getZodTypeName(zodField._def.innerType);
  }
  
  if (zodField instanceof z.ZodEnum) {
    return `enum(${zodField._def.values.join('|')})`;
  }
  
  if (zodField instanceof z.ZodLiteral) {
    return `literal(${zodField._def.value})`;
  }
  
  if (zodField instanceof z.ZodRecord) {
    return 'record';
  }
  
  return typeName || 'unknown';
}

/**
 * Formats schema descriptions as a markdown-formatted string for prompts
 */
export function formatSchemaDescriptions(schema: z.ZodObject<any>, schemaName: string): string {
  const descriptions = extractSchemaDescriptions(schema);
  const lines: string[] = [`## ${schemaName} Schema Fields:`];
  
  for (const [field, description] of Object.entries(descriptions)) {
    const zodField = schema.shape[field] as z.ZodTypeAny;
    const isOptional = zodField.isOptional();
    const type = getZodTypeName(zodField);
    
    lines.push(`- **${field}** ${isOptional ? '(optional)' : '(required)'} [${type}]: ${description}`);
  }
  
  return lines.join('\n');
}

/**
 * Gets formatted schema descriptions for ToolSpecSchema
 */
export function getToolSpecSchemaDescriptions(): string {
  return formatSchemaDescriptions(ToolSpecSchema, 'ToolSpec');
}

/**
 * Gets formatted schema descriptions for ToolParameterSchema
 */
export function getToolParameterSchemaDescriptions(): string {
  return formatSchemaDescriptions(ToolParameterSchema, 'ToolParameter');
}

/**
 * Gets all schema descriptions formatted for inclusion in prompts
 */
export function getAllSchemaDescriptions(): string {
  return [
    getToolSpecSchemaDescriptions(),
    '',
    getToolParameterSchemaDescriptions(),
  ].join('\n');
}
